#!/usr/bin/env node
/**
 * generate-token-types.ts
 * 
 * This script generates a token-types.ts file that defines a TokenType union
 * by analyzing token interface files and extracting their types.
 * 
 * This was generated by claude on 21/10/2025, because I'm too lazy to write something like this.
 */

import * as fs from 'fs';
import * as path from 'path';

// Default tokens directory if not specified
const DEFAULT_TOKENS_DIR = path.resolve(process.cwd(), './scanner/tokens');

// Get tokens directory from command line args or use default
const tokensDir = process.argv[2] ? path.resolve(process.argv[2]) : DEFAULT_TOKENS_DIR;
const indexFile = path.join(tokensDir, 'index.ts');
const outputFile = path.join(tokensDir, 'token-types.ts');

// Check if index.ts exists
if (!fs.existsSync(indexFile)) {
  console.error(`Error: index.ts not found in ${tokensDir}`);
  process.exit(1);
}

/**
 * Extracts all exported module paths from the index.ts file
 */
function extractExportedModules(indexFilePath: string): string[] {
  const content = fs.readFileSync(indexFilePath, 'utf8');
  const exportRegex = /export\s+\*\s+from\s+["'](.+)["']/g;
  
  const exportedModules: string[] = [];
  let match;
  
  while ((match = exportRegex.exec(content)) !== null) {
    if (match[1]) {
      exportedModules.push(match[1]);
    }
  }
  
  return exportedModules;
}

/**
 * Resolves a module path to an absolute file path
 */
function resolveModulePath(basePath: string, modulePath: string): string {
  const directory = path.dirname(basePath);
  
  // First, try direct resolution
  let resolvedPath = path.resolve(directory, modulePath);
  
  // If no extension, add .ts
  if (!path.extname(resolvedPath)) {
    resolvedPath += '.ts';
  }
  
  // Check if it's a file
  if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isFile()) {
    return resolvedPath;
  }
  
  // If resolvedPath without .ts is a directory, look for index.ts
  const dirPath = resolvedPath.endsWith('.ts') 
    ? resolvedPath.slice(0, -3) 
    : resolvedPath;
    
  if (fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {
    const indexPath = path.join(dirPath, 'index.ts');
    if (fs.existsSync(indexPath)) {
      return indexPath;
    }
  }
  
  console.warn(`Warning: Could not resolve module: ${modulePath} from ${basePath}`);
  return '';
}

/**
 * Extracts token interface names and their type literals from a file
 */
function extractTokenInterfacesFromFile(filePath: string): Array<{name: string, typeLiteral: string | null}> {
  if (!fs.existsSync(filePath)) {
    console.warn(`Warning: File not found: ${filePath}`);
    return [];
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  const results: Array<{name: string, typeLiteral: string | null}> = [];
  
  // Look for interfaces that extend Token
  const interfaceRegex = /export\s+interface\s+(\w+Token)\s+extends\s+Token\s*{([^}]*)}/gs;
  let interfaceMatch;
  
  while ((interfaceMatch = interfaceRegex.exec(content)) !== null) {
    const interfaceName = interfaceMatch[1];
    const interfaceBody = interfaceMatch[2];
    
    // Extract the type literal from the interface body
    const typeRegex = /type\s*:\s*['"]([^'"]+)['"]/;
    const typeMatch = interfaceBody.match(typeRegex);
    
    results.push({
      name: interfaceName,
      typeLiteral: typeMatch ? typeMatch[1] : null
    });
  }
  
  return results;
}

/**
 * Recursively processes a module and its exports to find token interfaces
 */
function processModule(modulePath: string, visited = new Set<string>()): Array<{name: string, typeLiteral: string | null}> {
  if (visited.has(modulePath)) {
    return []; // Avoid circular dependencies
  }
  
  visited.add(modulePath);
  
  // Check if this is a directory with an index.ts
  let filePath = modulePath;
  if (fs.existsSync(modulePath) && fs.statSync(modulePath).isDirectory()) {
    filePath = path.join(modulePath, 'index.ts');
    if (!fs.existsSync(filePath)) {
      return [];
    }
  }
  
  // Skip token.ts as it's the base interface
  if (filePath.endsWith('token.ts')) {
    return [];
  }
  
  // Process the file to find token interfaces
  const interfaces = extractTokenInterfacesFromFile(filePath);
  
  // If this is an index file, also process its exports
  if (filePath.endsWith('index.ts')) {
    const exportedModules = extractExportedModules(filePath);
    
    for (const exportPath of exportedModules) {
      const resolvedExport = resolveModulePath(filePath, exportPath);
      if (resolvedExport) {
        const nestedInterfaces = processModule(resolvedExport, visited);
        interfaces.push(...nestedInterfaces);
      }
    }
  }
  
  return interfaces;
}

/**
 * Main function to find all token interfaces
 */
function findAllTokenInterfaces(): Array<{name: string, typeLiteral: string | null}> {
  // Get all exported modules from index.ts
  const exportedModules = extractExportedModules(indexFile);
  
  // Track all found token interfaces
  const allTokenInterfaces: Array<{name: string, typeLiteral: string | null}> = [];
  
  // Process each exported module
  for (const modulePath of exportedModules) {
    const resolvedPath = resolveModulePath(indexFile, modulePath);
    if (resolvedPath) {
      const interfaces = processModule(resolvedPath);
      allTokenInterfaces.push(...interfaces);
    }
  }
  
  // Remove duplicates by interface name
  const uniqueInterfaces = new Map<string, {name: string, typeLiteral: string | null}>();
  for (const item of allTokenInterfaces) {
    if (!uniqueInterfaces.has(item.name)) {
      uniqueInterfaces.set(item.name, item);
    }
  }
  
  return Array.from(uniqueInterfaces.values()).sort((a, b) => a.name.localeCompare(b.name));
}

/**
 * Generates the token-types.ts file
 */
function generateTokenTypesFile(tokenInterfaces: Array<{name: string, typeLiteral: string | null}>): void {
  // Filter out interfaces without type literals
  const validInterfaces = tokenInterfaces.filter(item => item.typeLiteral !== null);
  
  if (validInterfaces.length === 0) {
    console.warn('Warning: No token interfaces with valid type literals found.');
    return;
  }
  
  // Create imports section
  const imports = validInterfaces
    .map(item => `  ${item.name},`)
    .join('\n');
  
  // Create the union type
  const unionType = validInterfaces
    .map(item => `  | ${item.name}['type']`)
    .join('\n');
  
  // Create the manual type union as fallback
  const manualUnionType = validInterfaces
    .filter(item => item.typeLiteral)
    .map(item => `  | '${item.typeLiteral}'`)
    .join('\n');
  
  // Create the file content
  const fileContent = `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-token-types script.
 * Generated on: ${new Date().toISOString()}
 */

import {
${imports}
} from './';

/**
 * Union type of all possible token types.
 * This is automatically extracted from all token interfaces.
 */
export type TokenType =
${unionType};

/**
 * Manual fallback union of all token type literals.
 * This is provided as a reference and for use with older TypeScript versions.
 */
export type TokenTypeLiteral =
${manualUnionType};
`;

  // Write the file
  fs.writeFileSync(outputFile, fileContent);
}

// Main execution
try {
  console.log(`Analyzing token exports from ${indexFile}...`);
  const tokenInterfaces = findAllTokenInterfaces();
  
  console.log(`Found ${tokenInterfaces.length} token interfaces`);
  
  if (tokenInterfaces.length === 0) {
    console.warn('Warning: No token interfaces found. Check if exports in index.ts are correct.');
  } else {
    console.log('Token interfaces:', tokenInterfaces.map(i => `${i.name}${i.typeLiteral ? ` (type: '${i.typeLiteral}')` : ''}`).join(', '));
    generateTokenTypesFile(tokenInterfaces);
    console.log(`âœ… Successfully generated token types in: ${outputFile}`);
  }
} catch (error) {
  console.error('Error generating token types:', error);
  process.exit(1);
}